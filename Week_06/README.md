# 第六周学习总结
## 动态规划（Dynamic Programming， DP）
- 这个启发于分治算法的思想，也是将复杂问题化解若干子问题，先求解小问题，再根据小问题的解得到原问题的解。但是DP与分治算法不同的是，DP分解的若干子问题，往往是互相不独立的，这时如果用分治算法求解，那么会对重叠子问题重复进行求解，从而使得浪费大量的时间。那么如果我们保存已经计算过的子问题的解，这样当再次计算该子问题时，可以直接使用，这样可以节约大量的时间。
  - DP正是利用一个表记录所有已经求解过的子问题的答案，只要一个子问题被求解过，就将其答案保存起来，无论以后的计算是否会用到，这就是DP的基本思想。

## 设计动态规划的四个步骤：
  - 刻画一个最优解的结构特征。
  - 递归地定义最优解的值。
  - 计算最优解的值，通常采用自底向上的方法。
  - 利用计算出的信息构造一个最优解。

##  动态规划的应具备两个要素：
  - 最优子结构性质。当问题的最优解包含了其子问题的最优解时，称该问题具有最有子结构性质。
  - 重叠子问题性质。

## 从钢条切割问题中总结动态规划

 - 这是算法导论中的一个例子：
 给定一根长度为n英寸的钢条和一个价格表Pi(i = 1,2,3,.....,n)，求钢条的最佳切割方案，使得销售收益最大。对于长度为n的钢条总共有种不同的切割方案。设距离钢条左端i（i = 1,2,....n-1）英寸处为可切割点，那么我们对每个切割点都可以选择切或者不切，则总共有种方法。因此暴力枚举每一种可能是不行的。
  设长度为n的钢条的最大收益为rn（n>=1）。

1. 最优子结构
    对于长度为n的钢条，假设第一刀在i（i= 1，.....n-1）处切割，使得收益最大。得到的两个小段钢条长度为i,n-i，那么对于其收益和也是最大的。假设不是，即在长度为i和长度为n-i的钢条分别有更好的切割方案，使得对应的收益更大，那么将这两个更优切割方案的收益相加，会得到一个比在i处切割所得收益更大的方案，那么说明开始第一刀就不是最优的，与假设相矛盾！因此本问题具有最有子结构的性质。
  2. 递归地定义最优解地值
   有一个更加简单明了的切割方法，假设我们最优的第一刀直接切出一个距离左端为i(i = 1, ....n-1)的钢条，这一段整体收益最大，即不再对这一段继续切割。我们只对剩余长度为n-i的钢条，继续切割，求其收益最大的切割方案，这样问题只化为一个更小的子问题。
  3. 可以计算最优解的值
  ```java
 int CutRod(int p[], int n)
{
    if(n == 0)
        return 0;
    int q = INT_MIN;
    for(int i = 1; i <= n; ++i)
        if(q < p[i]+CutRod(p, n-i))
            q = p[i]+CutRod(p, n-i);
    return q;
} 
  ```
- 由于大量的子问题被大量的重复计算，所以用空间来换取时间，申请一张表，来储存每次新子问题的答案，这样下次再遇到相同的子问题，直接查表取得，而无需计算，从而可以节约大量的时间。
```
int CutRod(int p[], int r[], int n){
    if(r[n] >= 0)
        return r[n];
    if(n == 0)
        return 0;
    int q = INT_MIN;
    for(int i = 1; i <= n; ++i)
        if(q < p[i]+CutRod(p, r, n-i))
            q = p[i]+CutRod(p, r, n-i);
    r[n] = q;
    return q;
}
 
 int MemoizedCutRod(int p[], int n)
{
    int r[n+1];
    for(int i = 0; i <= n; ++i)
        r[i] = INT_MIN;
    return 
}
```

## 总结一下
 1. 最优子结构
  - 证明问题最优解的第一个组成部分是做出一个选择。如，选择钢条第一次切割的位置，第一次选择矩阵链的划分位置等。做出这次选择会产生一个或者多个待解的子问题。
  - 对于一个给定问题，在其可能的第一步选择中，你假，定已经知道哪种选择才会得到最优解。现在无需关心这种选择是如何得到的，只是假定已经知道了这种选择。
  - 给定可获得最优解选择后，确定这次选择会产生哪些子问题，以及如何更好地刻画子空间。一个刻画子问题空间的经验是：保持子问题空间尽可能简单，只在必要时才扩展它。
 - 利用Cut-and-paste方法证明：作为原问题最优解的组成部分，每个子问题的解就是它本身的最优解。证明这一点，就是利用反证法：假定子问题的解不是其自身的最优解，那么我们可以从原问题中“剪切”掉这些非最优解，将最优解“粘贴”进去，从而得到一个原问题更优的解，这与最初的解释原问题的最优解的前提假设相矛盾。
  对于不同的问题，最优子结构体现在两个方面：
  - 原问题的最优解涉及多少个子问题
  - 在确定最优解使用哪些子问题时，我们需要考察多少种选择。

 2. 重叠子问题
  - 适合动态规划方法求解最优解的问题应该具备：子问题的空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。重叠子问题性质：递归算法反复求解相同的子问题。
  - 与之对应的分治算法，其求解问题时，通常在递归的每一步都生成全新的子问题。而动态规划则是，把子问题的解存放在一张表里，在需要的时候直接取出，此步操作的时间复杂仅是常量时间，故而降低了时间复杂度！